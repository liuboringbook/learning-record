# 浏览器内部机制

## 渲染机制

![1584958257030](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1584958257030.png)

### 什么是DOCTYPE及作用

DTD是一系列的语法规则，用来定义XML或HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。

DOCTYPE是用来生命文档类型，一个主要的用途便是文件的合法性验证，。如果文件代码不合法那么浏览器解决便会出现一些差错

```html
<!DOCTYPE html>
```

### 浏览器渲染过程

![1584958705898](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1584958705898.png)

1. 解析HTML文件，构建DOM树，同时浏览器主要负责下载CSS文件
2. CSS文件下载完成，解析CSS文件形成树形的数据结构，结合DOM树合并成RenderObject树
3. 布局(layout)   RenderObject树，负责RenderObject树中的元素尺寸，位置等计算
4. 绘制RenderObject树，绘制页面的像素信息
5. 浏览器主进程将默认的图层和复合图层教给GPU进程，GPU进程再讲各个图层合成，最后显示页面

#### 回流 Reflow

定义：

DOM结构中的各个元素都有自己的盒子(模型)，这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow

触发Reflow

+ 当你增加，删除，修改DOM节点，会导致Reflow
+ 当你移动DOM的位置，或者做动画的时候
+ 当你修改某些CSS样式的时候
+ 当你Resize窗口的时候(移动端没有这个问题)，或是滚动的时候
+ 当你修改网页的默认字体时

#### 重绘 Repaint

定义：

当页面中元素样式的改变并不影响他在文档流中的位置时(例如：color,background-color,visibility等)，浏览器会将新样式赋予给元素并重新绘制它，这个过程称之为重绘

#### 性能影响

回流比重绘的代价要更高

有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。现代浏览器会对频繁的回流或重绘操作进行优化：浏览器会维护一个队列,把所有引起回流和重绘的操作放入队列中,如果队列中的任务数量或者时间间隔达到一个阈值的,浏览器就会将队列清空,进行一次批处理,这样可以把多次回流和重绘变成一次。

当你访问以下属性或方法时,浏览器会立刻清空队列:

```javascript
clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftwidth、heightgetComputedStyle()getBoundingClientRect()
```

因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。

#### 如何避免

CSS

+ 避免使用table布局
+ 尽可能在DOM树的最末端改变class
+ 避免设置多层内联样式
+ 将动画效果应用到position属性为absolute或fixed的元素上
+ 避免使用css表达式(例如calc())

Javascript

+ 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性
+ 避免频繁操作DOM，创建一个documentFragment，在他上面应用所有DOM操作，最后再把它添加到文档中。
+ 也可以先为元素设置dispaly：none，操作结束再把它显示出来。因为在display尚需经为none的元素上进行的DOM操作不会引发回流和重绘
+ 对具有复杂动画的元素使用绝对定位，使他脱离文档流，否则会引发父元素及后续元素的频繁回流

## JS运行机制

![1586369680749](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1586369680749.png)

例题

```javascript
console.log(1);
setTimeout(function(){
    console.log(3)
},0)
console.log(2); //1,3,2
```

```javascript
console.log('A');
while(true){
    
}
console.log('B') //A 不会打印B，会在while中一直循环
```

```javascript
console.log('A');
setTimeout(function(){
    console.log('B')
})
while(true){
    
} //A  不会打印B，会在while中一直循环
```

### 进程与线程

进程

进程是CPU资源分配的最小单位。可以理解为一个独立运行且拥有自己的资源空间的任务程序

进程包括运行中的程序和程序所使用到的内存和系统资源

线程

线程是CPU调度的最小单位。线程是建立在进程的基础上的一次程序运行单位，线程是程序中的一个执行流。一个进程可以有多个线程。

### 单线程和多线程

一个进程中只有一个执行流称作单线程，即程序执行时，所走的程序按照连续顺序下来，前面的必须处理好，后面的才会执行

一个进程中由于多个执行流成为多线程，即在一个程序中可以同时运行多个不同的进程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。

### JS为什么是单线程

JS的单线程，与它的用途有关，作为浏览器脚本语言，JavaScript的主要用途是于用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时候浏览器无法做出抉择

### 事件循环(Event Loop)

JS分为同步任务和异步任务

同步任务都在主线程上执行，会形成一个执行栈主线程之为，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放一个事件回调。

一旦执行栈中所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到执行栈中，开始执行

```javascript
let setTimeoutCallBack = function() {
  console.log('我是定时器回调');
};
let httpCallback = function() {
  console.log('我是http请求回调');
}

// 同步任务
console.log('我是同步任务1');

// 异步定时任务
setTimeout(setTimeoutCallBack,1000);

// 异步http请求任务
ajax.get('/info',httpCallback);

// 同步任务
console.log('我是同步任务2');
```

JS引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的事件循环(Event Loop)

![img](https://user-gold-cdn.xitu.io/2020/1/18/16fb7acab03b35fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 异步任务

+ setTimeout和setInterval
+ DOM事件
+ ES6中的Promise

##  页面性能类

#### 提升页面性能方法

1. 资源压缩合并，减少HTTP请求
2. 非核心代码异步加载 
3. 利用浏览器缓存
4. 使用CDN
5. 预解析DNS

