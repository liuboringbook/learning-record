# 设计模式

## 订阅/发布模式(观察者)

pub/sub这个应该大家用到最广的设计模式

在这种模式中，并不属实一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的

特定活动并在状态改变后获得通知，订阅者因此也成为观察者，而被观察的对象成为发布者或主题，当发生了一个重要事件的时候，发布者会通知(调用)所有订阅者并可能经常以事件对象的形式传递消息

意义：可以使模块之间解耦



出现的场景：现在我们有一个需求：当用户成功完成一个应用程序时，后台需要出发相应的订单，消息和审核模块

常规的写法：

![img](https://user-gold-cdn.xitu.io/2020/5/20/17231a9ea6a9ca33?imageslim)

```javascript
function applySuccess(){
    //通知消息中心获取最新内容
    MessageCenter.fetch();
    //更新订单消息
    Order.update();
    //通知负责人审核
    Checker.alert();
}
```

但是随着涉及越来越多的模块，我们的代码变得越来越臃肿，难以维护。那就是发布和订阅模型可以节省灾难的时候。

![虎克小哥哥](https://user-gold-cdn.xitu.io/2020/5/20/17231a9eea838074?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

发布-订阅是一种消息传递范例，其中消息的发布不直接将消息发送给特定的订阅者，而是通过消息通道进行广播，订阅者可以通过订阅获得他们想要的消息。首先，让我们编写一个EventEmit函数：

```javascript
const EventEmit = function(){
    this.events ={};
    this.on = function(name,cb){
        if(this.events[name]){
            this.events[name].push(cb)
        }else{
            this.events[name] =[cb]
        }
    };
    this.trigger = function(name,...arg){
        if(this.events[name]){
            this.events[name].forEach(eventListener=>{
                eventListener(...arg)
            })
        }
    }
}
```

上面我们写了一个EventEmit，然后我们的代码可以更改为：

```javascript
let event =new EventEmit();
MessageCenter.fetch(){
    event.on('success',()=>{
        console.log('通知消息中心获取最新内容')
    });
}
Order.update(){
    event.on('success',()=>{
        console.log('更新订单消息')
    })
}
checker.alert(){
    event.on('success',()=>{
        console.log('通知负责人审核')
    })
}
event.trigger('success')
```

## 单例模式

单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点，实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。

适用场景：个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次，实现起来也很简单，用一个变量缓存即可。

