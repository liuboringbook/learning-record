# 进阶算法

## 排序和搜索

+ 排序：把某个乱序的数组变成升序或者降序的数组
+ 搜索：找出数组中某个元素的下标

### JS中的升序和搜索

+ jS中排序：数组的sort方法
+ JS中的搜索：数组的indexOf方法

## 排序算法

+ 冒泡排序
+ 选择排序
+ 插入排序
+ 归并排序
+ 快速排序
+ ...

### 冒泡排序

+ 比较所有相邻元素，如果第一个比第二个大，则交换他们
+ 一轮下来，可以保证最后一个数是最大的

+ 执行n-1轮，就可以完成排序

```javascript
    Array.prototype.bubbleSort = function(){
        for(let i=0;i<this.length-1;i++){
            for(let j=0;j<this.length-1-i;j++){
                if(this[j]>this[j+1]){
                    const temp = this[j];
                    this[j] =this[j+1];
                    this[j+1] = temp
                }
            }
        }
    }
```

时间复杂度O(n^2)

### 选择排序

+ 找到数组中的最小值，选中它并将其放置在第一位
+ 接着找到第二小的值，选中它并将其放置在第二位
+ 以此类推，执行n-1轮

```javascript
    Array.prototype.selectionSort = function(){
        for(let i=0;i<this.length-1;i++){
            let indexMin = i;
            for(let j=i;j<this.length;j++){
                if(this[j]<this[indexMin]){
                    indexMin =j
                }
            }
           if(indexMin !==i){
               const temp = this[i];
               this[i] =this[indexMin];
               this[indexMin] =temp;
           }
        }
    }
```

时间复杂度O(n^2)

### 插入排序

+ 从第二个数开始往前比
+ 比它大就往后排
+ 以此类推进行到最后一个数

```javascript
   Array.prototype.selectionSort = function(){
        for(let i=0;i<this.length-1;i++){
            let indexMin = i;
            for(let j=i;j<this.length;j++){
                if(this[j]<this[indexMin]){
                    indexMin =j
                }
            }
           if(indexMin !==i){
               const temp = this[i];
               this[i] =this[indexMin];
               this[indexMin] =temp;
           }
        }
    }
```

时间复杂度O(n^2)

### 归并排序

+ 分：把数组劈成两半，再递归地对子数组进行“分”操作，直到分成一个个单独的数
+ 合：把两个数合并成有序数组，再对有序数组进行合并，直到全部子数组合并成一个完整数组

#### 合并两个有序数组

+ 新建一个空数组res,用于存放最终排序后的数组
+ 比较两个有序数组的头部，较小者出队并推入res中
+ 如果两个数组还有值，就重复第二步

### 快速排序

+ 分区:从数组中任意选择一个"基准",所有比基准小的元素放在基准前面，比基准大的元素放在基准后面
+ 递归：递归地对基准前后的子数组进行分区



