# 前端算法1

## 什么是数据结构

1. 数据结构就是在计算机中存储和组织数据的方式
2. 我们知道，计算机中数据量非常庞大，如何以高效的方式组织和存储呢
3. 这就好比一个庞大的图书馆中存放大量书籍，我们不仅仅要把书放入，还应该在合适的时候取出来

结论：

+ 解决问题方法的效率，根数据的组织方式有关
+ 计算机中存储的数据量大，数据种类多
+ 以什么样的方式来存储和组织我们的数据，这就是数据结构需要考虑的问题

### 常见的数据结构

![1581051138528](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1581051138528.png)

+ 每一种都有其对应的应用场景，不同的数据结构的不同操作性能是不同的
+ 有的查询性能很快，有的插入速度很快，有的插入头和尾的速度很快
+ 有的做范围查找很快，有的允许元素重复，有的不允许元素重复等等
+ 在开发中如何选择，要根据具体的需求来选择

注意：数据结构和语言无关，常见的编程语言都有直接或者间接的使用上述的数据结构

单纯从客户端程序员的角度，我们并不需要过多的了解他们的实现细节，但是简单的使用不能让我们更加灵活的使用他们，了解真相，才能获得真正的自由

## 算法（解决问题的办法/步骤逻辑）

+ 一个有限指令集，每条指令的描述不依赖于语言
+ 接受一些输入（有些情况下不需要输入）
+ 产生输出
+ 一定在有限步骤之后终止

### 数组的缺点

+ 数组的创建通常需要申请一段连续的内存空间，并且大小是固定的，所以当当前数组不满足容量需求时，需要扩容
+ 而且在数组开头或中间位置插入数据的成本很高，需要大量元素的位移

### 栈结构

+ 栈也是一种非常常见的数据结构，并且在程序中的应用非常广泛
+ 栈和队列是比较常见的受限的线性结构

![1581063418521](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1581063418521.png)

+ 向一个栈插入新元素又被称作近栈，入栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素
+ 从一个栈删除元素又称作出栈或者退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素

+ 后进先出(LIFO)
+ 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对的，把另一端称为栈底

### 队列结构

+ 先进先出
+ 受限之处在它只允许在表的前端进行删除操作
+ 而在表的后端进行插入操作

队列常见操作

+ enqueue(element): 向队尾部添加一个(或多个)新的项
+ dequeue():移除队列的第一(即排在队列最前面的项),并返回被移除的元素
+ front() 返回队列中第一个元素---- 最先被添加，也将是最先被移除的元素。队列不做任何变动
+ isEmpty()：如果队列中不包含任何元素，返回true，否则返回false
+ size()： 返回队列包含的元素个数，与数组的length属性类似
+ toString()： 将队列中的内容，转成字符串形式

### 优先级队列 

+ 普通队列插入一个元素，数据会被放在后端，并且需要前面所有的元素都处理完成后才会处理前面的数据
+ 但是优先级队列在插入一个元素的时候回考虑该数据的优先级
+ 和其他数据优先级进行比较
+ 比较完成后，可以得出这个元素在队列中正确的位置
+ 其他处理方式和基本队列的处理方式一样

###  链表

+ 链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同
+ 要存储多个元素，另一个选择就是链表
+ 但是不同于数组，链表中的元素在内存中不必是连续的空间
+ 链表的每个元素由元素本身的节点和一个指定下一个元素的引用组成

相对于数组，链表的优点

+ 内存空间不是必须连续的，可以充分利用计算机的内存，实现灵活的内存动态管理
+ 链表不必在创建时确定大小，并且大小可以无限的延伸下去
+ 链表在插入和删除数据时，时间复杂度可以达到O(1)，相对数组效率高很多

相对于数组，链表的一些缺点：

+ 链表访问任何一个位置的元素时，都需要从头开始访问(无法跳过第一个元素访问任何一个元素)
+ 无法通过下标直接访问元素，需要从头一个个访问，直接找到对应的元素

![1581081097101](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1581081097101.png)

链表常见操作：

+ append(element): 向列表尾部添加一个新的项
+ insert(position,element): 向列表的特定位置插入一个新的项
+ get(position)： 获取对应位置的元素
+ indexOf(element): 返回元素在列表中的索引。如果列表中没有该元素则返回-1
+ update(position): 修改某个位置的元素
+ removeAt(position): 从列表的特定位置移除一项
+ remove(element): 从列表中移除一项
+ isEmpty()： 如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false
+ size()：返回链表包含的元素个数。与数组的length属性类似
+ toString(): 由于列表项使用了node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值

### 集合

+ 几乎每种编程语言中，都有集合结构
+ 集合比较常见的实现方式是哈希表
+ 集合通常是由一组无序的，不能重复的元素构成的

操作方法：

+ add(value):向集合添加一个新的项。
+ remove(value)：从集合移除一个值
+ has(value): 如果值在集合中，返回true，否则返回false
+ clear()：移除集合中的所有项
+ size()： 返回集合所包含元素的数量。与数组的length属性类似
+ values(): 返回一个包含集合中所有值的数组

集合间操作：

+ 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合
+ 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合
+ 差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在第二个集合的元素的新集合
+ 子集：验证一个给定集合是否是另一个集合的子集

### 哈希表

+ 几乎所有的编程语言都有直接或者应用的盈盈这种数据结构

+ 哈希表通常是基于数组进行实现的

哈希表和数组相比的优势

+ 可以提供非常快速的插入-删除-查找操作
+ 无论多少数据，插入和删除值需要接近常量的时间：即O(1)的时间级，实际上，只需要几个机器指令即可完成
+ 哈希表的速度比树还要快，基本可以瞬间查找想要的元素
+ 哈希表相对于树来说编码要容易很多

哈希表对于数组的一些不足：

+ 哈希表中的数据是没有顺序的，并不能以一种固定的方式来遍历其中的元素
+ 通常情况下，哈希表中key是不允许重复的，不能放置相同的key，用于保存不同的元素

### 哈希化

需要一种压缩方法，把幂的连乘方案系统中得到巨大整数范围压缩到可接受的数组范围中

哈希化： 将大数字转化成数组范围内下表的过程，我们称之为哈希化

哈希函数：通常我们会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数叫哈希函数

哈希表：最终将数据插入到的这个数组，对整个结构的封装，我们就称之为一个哈希表

