# 网络通信和安全

## HTTP协议

![1583916860125](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1583916860125.png)

### HTTP协议的主要特点

+ 简单快速(每个资源只需要知道资源地址，就可以进行传输)
+ 灵活(可以传输不同的文件类型)
+ 无连接(只有当发起请求的时候，才会进行连接，没有发送请求，是断开的状态)
+ 无状态(无法区分上次连接和这次连接的客户端是否是同一个身份)

### HTTP报文的组成部分

![1583917254581](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1583917254581.png)

空行是用于隔离请求头和请求体

### POST和GET的区别

+ GET在浏览器回退时是无害的，而POST会再次提交请求
+ GET产生的URL地址可以被收藏，而POST不可以
+ GET请求参数会被完整的保留在浏览器历史记录里，而POST中的参数不会被保留
+ GET请求的URL中传输的参数是有长度限制的，而POST没有限制
+ 对参数的数据类型，GET值接收ASCII字符，而POST没有限制
+ GET参数通过URL传递，而POST放在Request body中
+ GET只能进行URL编码。而POST支持多种编码方式
+ GET请求会被浏览器主动缓存，而POST不会。除非手动收藏

### 状态码

1xx: 提示信息----表示请求已被接收

2xx:成功----表示请求已被成功接收

3xx: 重定向---要完成请求必须进行更进一步的操作

4xx: 客户端错误---请求有语法错误或请求无法实现

5xx: 服务端错误---服务器未能实现合法的请求

200 ok： 客户端请求成功

301：所请求的页面已经转移到新的url

303：所请求的页面已经临时转移到新的url

400: 客户端请求有语法错误，不能被服务器所理解

403: 对被请求的页面访问被禁止

404: 请求资源不存在

500:服务器发生不可预期的错误

503：请求未完成，服务器临时过载或当机，一段时间后可能恢复正常

### 持久连接

HTTP协议采用"请求-应答"模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接

当使用Keep-alive模式时，Keep-Alive工鞥使客户端到服务器端的连接持续有效，当出现服务器的后续请求时，Keep-Alive工鞥避免了建立或重新建立连接

### 管线化

![1583918704753](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1583918704753.png)

将所有请求打包发送给服务器，服务器也统一打包发送给客户端

![1583918812984](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1583918812984.png)

### WebSocket

webSocket是HTML5提出的一种客户端和服务端通讯的全双功协议，由客户端发起请求，建立连接之后不仅客户端可以主动向服务端发送请求，服务端可以主动向客户端推送信息。

## 通信类

![1583919070396](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1583919070396.png)

### 什么是同源策略及限制

同源策略限制从一个源(协议，端口，域名)加载的文档如何与来自另一个源的资源进行交互。这是一个隔离潜在恶意文件的关键的安全机制。

同源策略限制一下几种行为:

1. Cookie，LocalStorage和IndexDB无法读取
2. DOM和JS对象无法获得
3. Ajax请求无法发送

### 前后端如何通信

+ Ajax
+ webSocket(不限制同源策略)
+ CORS(支持同源，也可以跨域通信)

### Ajax

#### Ajax原生JS操作

```javascript
//一，创建Ajax实例
let xhr = new XMLHttpRequest();
//二，打开请求: 发送请求之前的一些配置
//1.HTTP METHOD:GET/POST
//2.url:接口地址
//3.async 设置ajax的同步异步
xhr.open(method,url,async,[user-name],[user-pass])
//三,事件监听:一般监听的都是readystatechange事件，基于这个事件可以获取服务器返回的响应头响应主体
xhr.onreadystatechange =function(){
    if(xhr.readyState===4 && xhr.status===200){
        console.log(xhr.responseText);
    }
};
//四，发送Ajax请求，从这步开始，当前Ajax任务开始，如果Ajax是同步的，后续代码不会执行，要等到Ajax状态成功后再执行
xhr.send([请求主题内容])
```

手写Ajax

```javascript
//对请求data进行格式化处理
function formateData(data){
    let arr =[];
    for(let key in data){
        //避免有&,=,?字符，对这些字符进行序列化
        arr.push(encodeURIComponent(key)+'='+data[key])
    }
    return arr.join('&')
}
function ajax(params){
    //先对params进行处理，防止为空
    params =params||{};
    params.data =parmas.data||{};
    //普通GET,POST请求
    params.type = (params.type||'GET').toUpperCase();
    Params.data =formateData(params.data);
    let xhr =new XMLHttpRequest();
    if(parmas.type ==='GET'){
        xhr.open(params.type,params.url+'?'+params.data,true);
        xhr.send();
    }else{
        xhr.open(params.type,params.url,true);
        xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded")
        xhr.send(params.data)
    }
    xhr.onReadystatechange = function(){
        if(xhr.readyState === 4){
            if(xhr.status==200||xhr.status ===304||xhr.status==206){
                var res;
                if(params.success&& params.success instanceof Function){
                    res.JSON.parse(xhr.responseText);
                    params.success.call(xhr,res)
                }
            }else{
                if(params.error && params.error instanceof Function){
                    res =xhr.responseText;
                    params.error.call(xhr,res)
                }
            }
        }
    }
}
```



### 跨域通信的几种方法

 