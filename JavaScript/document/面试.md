# 面试

## DOM事件类

![1583690630474](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1583690630474.png)

### 事件级别

事件处理程序就是响应某个时间的函数，DOM事件分为3个级别：DOM 0级事件处理，DOM2级事件处理，DOM3级事件处理

1. DOM0级事件

`el.onclick=function(){}`

```javascript
var btn = document.getElementById('btn');
btn.onclick = function(){
    alert(this.innerHTML);
}
```

当希望为同一个元素/标签绑定多个同类型事件的时候(如给上面这个btn元素绑定三个点击事件),是不被允许的。DOM0级事件绑定，给元素的事件行为绑定方法，这些方法都是在当前元素事件行为的冒泡阶段(或者目标阶段)执行的

2. DOM 2级事件

`el.addEventlistener(event-name,callback,useCapture)`

event-name:事件名称，可以是标准的DOM事件

callback：回调函数，当事件触发时，函数会被注入一个参数为当前的事件对象event

userCapture：默认是false，代表事件句柄在冒泡阶段执行

```javascript
var btn = document.getElement('btn');
btn.addEventListener("click",test,false);
function test(e){
   e = e || window.event
    alert(e.target|| e.srcElement.innerHTML);
    btn.removeListener("click",test)
}
```

IE9以下的IE浏览器不支持addEventListener()和removeListener()，使用attachEven()与detachEvent()代替，因为IE9以下不支持事件捕获的，所以也没有第三个参数，第一个事件名称前要加on。

3. DOM 3级事件

+ 在DOM2级事件的基础上添加了更多的事件类型。

+ UI事件，当用户与页面上的元素交互时触发，如：load、scroll

+ 焦点事件，当元素获得或失去焦点时触发，如：blur、focus

+ 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup

+ 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel

+ 文本事件，当在文档中输入文本时触发，如：textInput

+ 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress

+ 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart

+ 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified

+ 同时DOM3级事件也允许使用者自定义一些事件。

### DOM事件模型和事件流

DOM事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播。这种传播分为三个阶段。

1. 捕获阶段：事件从window对象自上而下向目标节点传播的阶段
2. 目标阶段：真正的目标节点正在处理事件的阶段；
3. 冒泡阶段：事件从目标节点自下而上向window对象传播的阶段

![1583691069309](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1583691069309.png)

### 描述DOM事件捕获的具体流程

![1583691264174](C:\Users\刘如刚\AppData\Roaming\Typora\typora-user-images\1583691264174.png)

捕获是从上到下，事件先从window对象，然后再到document(对象)，然后是html标签(通过document.documentElement获取html标签)，然后是body标签(通过document.body获取body标签)，然后按照普通的html结构一层一层往下传，最后到达目标元素

而事件冒泡的流程刚好是事件捕获的逆过程。

### 事件代理(事件委托)

由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理子元素的事件。这种方法叫做事件对的代理

1. 优点 
  + 减少内存消耗，提高性能
假设有一个列表，列表之中有大量的列表项，我们需要在点击每个列表项的时候响应一个事件
如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。借助事件代理，我们只需要给父容器ul绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的click行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。
  +  动态绑定事件
在很多时候，我们需要通过用户操作动态的增删列表项元素，如果一开始给每个子元素绑定事件，那么在列表发生变化时，就需要重新给新增的元素绑定事件，给即将删去的元素解绑事件，如果用事件代理就会省去很多这样麻烦。
2. 如何实现

   ```javascript
   //给父层元素绑定事件
   document.getElementId('list').addEventListener('click',function(e){
       //兼容性处理
       var event =e||window.event
       var target =event.target ||event.srcElemnt;
       //判断是否匹配目标元素
       if(target.nodeName.toLocaleLowerCase === 'li'){
           console.log('this content is:',target.innerHTML)
       }
   })
   ```

   ### Event对象常见的应用

+ `event.preventDefault()`

   如果调用这个方法，默认事件行为将不再触发。什么是默认事件呢？例如表单一点击提交按钮(suvmit)跳转页面，a标签默认页面跳转或是锚点定位等。

   ```html
   <a id="test" href="http://www.cnblogs.com">链接</a>
   <script>
       var test=document.getElementById('test');
       test.onclick =function(e){
           e =e ||window.event;
           e.preventDefault();
       }
   </script>
   ```

   实现输入框最多只能输入六个字符

   ```html
   <input type="text" id="tempInp">
   <script>
      var tempInp = document.getElementById('tempInp')
      tempInp.onkeydown  =function(ev){
          ev=ev||window.event;
          let val =this.value.trim();//trim去除字符串首位空格
          let len =val.length
          if(len>=6){
              this.value =val.substr(0,6);
              //阻止默认行为去除特殊按键
              let code =ev.which ||ev.keyCode;
              if(!/^(46|8|37|38|39|40)$/.test(code)){
                  ev.preventDefault();
              }
          }
      }
   </script>
   ```

+ `event.stopPropagation()`& `stop.stopImmediatePropagation()`

   `event.stopPropagation()`方法阻止事件冒泡到父元素，阻止任何父事件处理程序被执行。

`stop.stopImmediatePropagation()`既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其他监听器被触发。而`stopPropagtion`只能实现前者的效果。

```html
<button id="btn">click me</button>
<script>
  var btn =document.querySelector('#btn');
  btn.addEventListener('click',function(event){
      console.log('btn click 1');
      event.stopImmediatePropagation();
  });
  btn.addEventListener('click',function(){
      console.log('btn click 2')
  })
  document.body.addEventListener('click',function(){
      console.log('body click')
  })
  //btn click 1  
</script>	
```

使用`stop.stopImmediatePropagation()`后。点击按钮时，不仅仅body绑定事件不会触发，与此同按钮的另一个点击事件也不会触发。

+ `event.target `& `event,currentTarget`

`event.target`指向引起触发事件的元素，而`event.currenttTarget`则是事件绑定的元素，也就是说`event.currentTarget`始终是监听事件者，而`event.target`是事件的真正发出者

```html
<div id="a">
    <div id="b">
        <div id="c">
            <div id="d">
            </div>	
        </div>	
    </div>
</div>
<script>
  document.getElementId('a').addEventListener('click',function(e){
      console.log('target:’+e.target.id+'&currentTarget:'+e.currentTarget.id)
  })
    document.getElementId('b').addEventListener('click',function(e){
      console.log('target:’+e.target.id+'&currentTarget:'+e.currentTarget.id)
  })
    document.getElementId('c').addEventListener('click',function(e){
      console.log('target:’+e.target.id+'&currentTarget:'+e.currentTarget.id)
  })
    document.getElementId('d').addEventListener('click',function(e){
      console.log('target:’+e.target.id+'&currentTarget:'+e.currentTarget.id)
  })
</script>	
```

![img](https://user-gold-cdn.xitu.io/2018/12/4/1677974dad275fb7?imageslim)

当点击最里层的元素d的时候会依次输出

```javascript
target:d&currentTarget:d
target:d&currentTarget:c
target:d&currentTarget:b
target:d&currentTarget:a
```

+ 自定义事件

```javascript
var eve =new event('custome');
ev.addEventListener('custome',function(){
    console.log('custome')
})
ev.dispatchEvent(eve);
```

